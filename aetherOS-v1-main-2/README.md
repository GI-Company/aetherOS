# AetherOS: The Quorium Architecture Blueprint

**Version 1.0 | Status: Production Ready**

AetherOS is a cloud-native, AI-first operating system where user intent is translated directly into action by a secure, intelligent kernel. This `README` provides a comprehensive overview of its architecture, components, and setup instructions.

---

## 1. Getting Started: Running AetherOS

Follow these steps to set up and run the AetherOS Kernel and Shell.

### Prerequisites

*   Go (version 1.21 or later)
*   Node.js (version 20.x or later)
*   A Firebase project with **Authentication**, **Firestore**, and **Cloud Storage** enabled.

### Backend Kernel Setup (Go)

1.  **Set Environment Variables**:
    Create a `.env` file in the `aetherOS-v1-main-2` directory. You will need two variables:
    *   `GOOGLE_APPLICATION_CREDENTIALS`: Path to your Firebase service account JSON key.
    *   `GEMINI_API_KEY`: Your API key for the Google Gemini API.

    ```sh
    # aetherOS-v1-main-2/.env
    GOOGLE_APPLICATION_CREDENTIALS="/path/to/your/service-account.json"
    GEMINI_API_KEY="your-gemini-api-key"
    ```

2.  **Run the Kernel**:
    Navigate to the `broker` directory and run the `main.go` application.

    ```sh
    cd aetherOS-v1-main-2/broker
    go mod tidy
    go run main.go
    ```

    The Go kernel will start on `localhost:8080`.

### Frontend Shell Setup (Next.js)

1.  **Install Dependencies**:
    Navigate to the `aetherOS-v1-main-2` directory (the root of the Next.js project) and install the npm packages.

    ```sh
    cd aetherOS-v1-main-2
    npm install
    ```

2.  **Run the Shell**:
    Start the Next.js development server.

    ```sh
    npm run dev
    ```

    The AetherOS shell will be available at `http://localhost:3000`.

---

## 2. Architectural Overview: The Quorium Stack

The AetherOS architecture is designed around three core principles: **AI as the Core**, **Decoupled Services**, and **Cloud-Native Persistence**. It is composed of two primary macro-components: the **Aether Kernel (Go Backend)** and the **Aether Shell (Next.js Frontend)**.

### Layer 1: The Aether Kernel (Go Backend)

The Kernel is the central nervous system of AetherOS. It is a secure, high-performance Go application responsible for service orchestration, permission enforcement, and computation.

*   **Core Components**:
    *   **Message Broker (`/broker/aether/hub.go`, `topic.go`)**: A high-speed, in-memory pub-sub system that routes all inter-service and client-kernel communication.
    *   **WebSocket Gateway (`/broker/server/bus.go`)**: A secure bridge that exposes the internal message bus to the frontend shell over a persistent WebSocket connection.
    *   **Permission Manager (`/broker/aether/permissions.go`)**: The security heart of the kernel. It parses `manifest.json` files for all installed applications and enforces their declared permissions (e.g., `ai_access`, `filesystem_write`) on every request.

*   **Kernel Services (`/broker/services`)**: These are the long-running daemons that provide the core functionality of AetherOS. Each service listens on specific topics on the message bus.
    *   **`AIService`**: The primary intelligence. It interfaces with the Google Gemini SDK to handle all generative tasks.
    *   **`VfsService`**: A secure proxy for the file system, performing all operations against Firebase Cloud Storage.
    *   **`ComputeService`**: The sandboxed execution engine. It uses the **Wazero** runtime to securely execute compiled WASM binaries.
    *   **`AgentService`**: The autonomous execution orchestrator. It manages multi-step `TaskGraphs` generated by the AI.
    *   **`InstallService`**: Manages the secure installation of new applications, validating their manifests and registering their permissions.

### Layer 2: The Aether Shell (Next.js Frontend)

The Shell is the unified presentation layer for AetherOS, built as a modern, single-page application that renders the entire user experience.

*   **Technology**: Next.js, React, TypeScript, Tailwind CSS, ShadCN UI.
*   **Core Components**:
    *   **`AetherClient` (`/src/lib/aether_sdk_client.ts`)**: A lightweight SDK that manages the WebSocket connection to the kernel.
    *   **`useAppAether` Hook (`/src/lib/use-app-aether.ts`)**: A critical hook that provides a scoped version of the `AetherClient` to each running application, automatically injecting the app's ID into every message for permission checking by the kernel.
    *   **`Desktop` (`/src/app/apps/desktop.tsx`)**: The root component managing the workspace, window states, and user sessions.
    *   **`Window` Manager (`/src/components/aether-os/window.tsx`)**: A sophisticated component for fluid, animated window management.
    *   **Persistent Cloud Workspace**: The state of open windows is automatically saved to a user's Firestore document and restored on login.

### Layer 3: Cloud Persistence & Services (Firebase)

Firebase provides the foundational, serverless infrastructure that makes AetherOS a truly cloud-native platform.

*   **Firebase Authentication**: Manages user identity (Google, Apple, Anonymous).
*   **Firebase Cloud Storage**: The official, persistent file system, exclusively managed by the kernel's `VfsService`.
*   **Firestore Database**: The primary database for all user and application state, including user preferences, workspace layouts, and agent task graphs.

---

## 3. The Computing Paradigm: Orchestrated Intent

The interaction flow in AetherOS is fundamentally different from a traditional OS:

1.  **User Action**: A user interacts with an application component (e.g., clicks "Save").
2.  **Publish Intent**: The application component publishes the user's *intent* as a JSON message to a specific topic on the message bus (e.g., `vfs:write`). The message automatically includes the app's ID via the `useAppAether` hook.
3.  **Kernel Orchestration & Security**: The Go kernel's `PermissionManager` intercepts the message and verifies that the originating app has the required permission (e.g., `filesystem_write`).
4.  **Service Execution**: If authorized, the message is routed to the appropriate service (e.g., `VfsService`), which executes the request against the backend resource (Firebase Storage).
5.  **Publish Result**: The service publishes the result (e.g., a success message) back to a response topic on the bus (e.g., `vfs:write:result`).
6.  **UI Update**: The originating application component, subscribed to the response topic, receives the result and updates its UI accordingly.

This model ensures the UI is always responsive, the system is secure and extensible, and all operations are centrally managed by the intelligent kernel.
