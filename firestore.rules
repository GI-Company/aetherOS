/**
 * @file Firestore Security Rules for AetherOS.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for data nested under `/users/{userId}`.
 * Applications metadata stored under `/applications/{applicationId}` are publicly readable.
 *
 * Data Structure:
 * - `/users/{userId}/virtualFiles/{virtualFileId}`: Virtual files owned by a specific user.
 * - `/users/{userId}/tags/{tagId}`: Tags owned by a specific user.
 * - `/users/{userId}/desktopSpaces/{desktopSpaceId}`: Desktop space configurations for a specific user.
 * - `/users/{userId}/osbidibiWorkflows/{osbidibiWorkflowId}`: OS workflows owned by a specific user.
 * - `/applications/{applicationId}`: Application metadata (publicly readable).
 *
 * Key Security Decisions:
 * - User data is strictly segregated and only accessible by the owning user.
 * - Application metadata is publicly readable.
 * - Write operations (create, update, delete) MUST NEVER use `if true;`.
 *
 * Denormalization for Authorization:
 *  No explicit denormalization is required as path-based ownership is used to secure user data.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the request is made by an authenticated user.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user's UID matches the provided userId.
     * @param {string} userId - The user ID to compare against the authenticated user's UID.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Checks if the authenticated user is the owner of the existing document.
     * @param {string} userId - The user ID to compare against the authenticated user's UID.
     */
    function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
    }

    /**
     * @description Security rules for virtual files owned by a specific user.
     * @path /users/{userId}/virtualFiles/{virtualFileId}
     * @allow (create) User 'user123' creates a new virtual file with a matching userId.
     * @allow (get, list) User 'user123' reads their own virtual files.
     * @deny (create) User 'user456' attempts to create a virtual file under 'user123''s path.
     * @deny (update, delete) User attempts to modify or delete a non-existent virtual file.
     * @principle Enforces document ownership for writes and restricts access to a user's own data tree.
     */
    match /users/{userId}/virtualFiles/{virtualFileId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.id == virtualFileId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Security rules for tags owned by a specific user.
     * @path /users/{userId}/tags/{tagId}
     * @allow (create) User 'user123' creates a new tag with a matching userId.
     * @allow (get, list) User 'user123' reads their own tags.
     * @deny (create) User 'user456' attempts to create a tag under 'user123''s path.
     * @deny (update, delete) User attempts to modify or delete a non-existent tag.
     * @principle Enforces document ownership for writes and restricts access to a user's own data tree.
     */
    match /users/{userId}/tags/{tagId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.id == tagId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Security rules for desktop spaces owned by a specific user.
     * @path /users/{userId}/desktopSpaces/{desktopSpaceId}
     * @allow (create) User 'user123' creates a new desktop space with a matching userId.
     * @allow (get, list) User 'user123' reads their own desktop spaces.
     * @deny (create) User 'user456' attempts to create a desktop space under 'user123''s path.
     * @deny (update, delete) User attempts to modify or delete a non-existent desktop space.
     * @principle Enforces document ownership for writes and restricts access to a user's own data tree.
     */
    match /users/{userId}/desktopSpaces/{desktopSpaceId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.id == desktopSpaceId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Security rules for OS workflows owned by a specific user.
     * @path /users/{userId}/osbidibiWorkflows/{osbidibiWorkflowId}
     * @allow (create) User 'user123' creates a new OS workflow with a matching userId.
     * @allow (get, list) User 'user123' reads their own OS workflows.
     * @deny (create) User 'user456' attempts to create an OS workflow under 'user123''s path.
     * @deny (update, delete) User attempts to modify or delete a non-existent OS workflow.
     * @principle Enforces document ownership for writes and restricts access to a user's own data tree.
     */
    match /users/{userId}/osbidibiWorkflows/{osbidibiWorkflowId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.id == osbidibiWorkflowId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Security rules for application metadata. Publicly readable, owner-only writable.
     * @path /applications/{applicationId}
     * @allow (get, list) Any user (or no user) can read application metadata.
     * @deny (create, update, delete) No one can modify existing application metadata.
     * @principle Allows public read access but restricts all write access.
     */
    match /applications/{applicationId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }
  }
}